from __future__ import annotations
from pathlib import Path
from urllib.request import urlopen
import ssl
import shutil

from .utils import ensure_dir
from .html_kit import HtmlAttr, SitePath, HtmlId
from .markdown_parser import CssClass  # for layout / viz / table classes

# ECharts bundle (global echarts)
ECHARTS_URL = "https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"


def _download_with_ssl_bypass(url: str, dest: Path) -> None:
    """
    Download a URL, bypassing SSL verification.

    On failure, we raise an exception instead of writing a stub file.
    That way builds fail fast and do not leave partially-filled assets.
    """
    ctx = ssl._create_unverified_context()
    with urlopen(url, context=ctx) as resp, dest.open("wb") as f:
        f.write(resp.read())


def _copy_static_src_assets(site_root: Path) -> None:
    """
    Copy all JS and CSS assets from ducksite/static_src into site_root/js and site_root/css.

    This treats ducksite/static_src as the canonical "library" for the runtime
    assets. We always overwrite so a new ducksite version propagates on the next
    build, without users needing to manage these files themselves.

    Users who want custom styling are expected to add *additional* CSS files in
    their project, not modify the generated copies in site_root.
    """
    static_src_dir = Path(__file__).with_name("static_src")
    if not static_src_dir.exists():
        return

    js_root = site_root / "js"
    css_root = site_root / "css"
    ensure_dir(js_root)
    ensure_dir(css_root)

    # JS modules
    for src in static_src_dir.glob("*.js"):
        dest = js_root / src.name
        shutil.copy2(src, dest)
        print(f"[ducksite] synced JS asset {dest}")

    # CSS files (e.g. ducksite.css, charts.css)
    for src in static_src_dir.glob("*.css"):
        dest = css_root / src.name
        shutil.copy2(src, dest)
        print(f"[ducksite] synced CSS asset {dest}")


def _to_camel(enum_name: str) -> str:
    """
    Convert ENUM_STYLE names to camelCase for JS keys.
    Example: 'VIZ_CONTAINER' -> 'vizContainer'
             'LAYOUT_GRID'   -> 'layoutGrid'
    """
    parts = enum_name.lower().split("_")
    if not parts:
        return enum_name.lower()
    return parts[0] + "".join(p.capitalize() for p in parts[1:])


def _write_contract_module(js_root: Path) -> None:
    """
    Write ducksite_contract.js into js_root, mirroring key DOM/URL contracts
    from the Python enums into a JS module.

    Exports:
      CLASS: CSS class names (layoutGrid, layoutRow, layoutCol, vizContainer, tableContainer)
      DATA:  data-* attributes (vizId, tableId, cols, gap)
      ID:    element IDs (pageConfigJson)
      PATH:  root/sql/data/js/css URL roots
    """
    dest = js_root / "ducksite_contract.js"
    lines: list[str] = []

    lines.append("// AUTO-GENERATED by ducksite.js_assets.ensure_js_assets\n")
    lines.append("// DO NOT EDIT THIS FILE DIRECTLY.\n\n")

    # CLASS
    lines.append("export const CLASS = {\n")
    for cls in CssClass:
        if cls.name == "SPAN_PREFIX":
            continue
        key = _to_camel(cls.name)  # e.g. 'layoutGrid', 'vizContainer'
        value = cls.value
        lines.append(f'  {key}: "{value}",\n')
    lines.append("};\n\n")

    # DATA
    data_mapping = {
        "cols": HtmlAttr.DATA_COLS.value,
        "gap": HtmlAttr.DATA_GAP.value,
        "vizId": HtmlAttr.DATA_VIZ_ID.value,
        "tableId": HtmlAttr.DATA_TABLE_ID.value,
    }
    lines.append("export const DATA = {\n")
    for key, value in data_mapping.items():
        lines.append(f'  {key}: "{value}",\n')
    lines.append("};\n\n")

    # ID
    lines.append("export const ID = {\n")
    lines.append(f'  pageConfigJson: "{HtmlId.PAGE_CONFIG_JSON.value}",\n')
    lines.append("};\n\n")

    # PATH
    lines.append("export const PATH = {\n")
    lines.append(f'  root: "{SitePath.ROOT.value}",\n')
    lines.append(f'  sqlRoot: "{SitePath.SQL.value}",\n')
    lines.append(f'  dataRoot: "{SitePath.DATA.value}",\n')
    lines.append(f'  jsRoot: "{SitePath.JS.value}",\n')
    lines.append(f'  cssRoot: "{SitePath.CSS.value}",\n')
    lines.append("};\n")

    dest.write_text("".join(lines), encoding="utf-8")
    print(f"[ducksite] wrote contract module {dest}")


def ensure_js_assets(root: Path, site_root: Path) -> None:
    """
    Ensure JS/CSS assets exist under site_root (which is served as the HTTP root).

    Layout:
      site_root/
        index.html
        major/index.html
        minor/index.html
        js/
          echarts.min.js
          main.js
          page_runtime.js
          page_config.js
          inputs.js
          duckdb_runtime.js
          render.js
          ducksite_contract.js   (generated)
        css/
          ducksite.css
          charts.css
        data/
          *.parquet
        sql/
          *.sql
    """
    ensure_dir(site_root)

    js_root = site_root / "js"
    css_root = site_root / "css"
    ensure_dir(js_root)
    ensure_dir(css_root)

    # 1) ECharts JS into js/
    echarts_js = js_root / "echarts.min.js"
    if not echarts_js.exists():
        print(f"[ducksite] echarts.min.js not found at {echarts_js}, downloading from {ECHARTS_URL}")
        _download_with_ssl_bypass(ECHARTS_URL, echarts_js)
        print(f"[ducksite] echarts.min.js downloaded to {echarts_js}")
    else:
        print(f"[ducksite] echarts.min.js already present at {echarts_js}")

    # 2) Our runtime modules and CSS from static_src/
    _copy_static_src_assets(site_root)

    # 3) Write the JS contract module from Python enums
    _write_contract_module(js_root)


if __name__ == "__main__":
    ensure_js_assets(Path("."), Path("static"))
    print("JS/CSS assets ensured under static/js/ and static/css/")
